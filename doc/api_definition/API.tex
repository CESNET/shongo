\documentclass[a4paper]{report}
\usepackage{geometry}
\geometry{paper=a4paper}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenx}
\usepackage{palatino}
\usepackage{mathpazo}
\usepackage{microtype}
\renewcommand*\ttdefault{txtt}

\usepackage[czech,english]{babel}

\usepackage[pdftex,breaklinks=true,pdfborder={0 0 0}]{hyperref}
\usepackage{url}
\usepackage{paralist}
\usepackage{graphicx}
\usepackage{xtab}
\usepackage{booktabs}
\usepackage{calc}
\usepackage{ifthen}
\usepackage{xspace}
\usepackage{verbatim}

\usepackage{relsize}
\usepackage{xcolor}
\usepackage{listingsutf8}
\definecolor{lstbackground}{gray}{0.8}
\definecolor{lstkeywordcolor}{rgb}{0,0,0.4}
\lstset{
extendedchars=false,
alsoletter={-},
basicstyle=\fontfamily{txtt}\fontseries{b}\selectfont,
keywordstyle=\color{lstkeywordcolor}\selectfont,
commentstyle=\color{black!60}\selectfont,
numbers=left, numberstyle=\tiny, stepnumber=2, numbersep=5pt, frame=single,
backgroundcolor=\color{lstbackground}, showstringspaces=false
}
\lstdefinestyle{mensi}{
basicstyle=\smaller[1]\fontfamily{txtt}\fontseries{b}\selectfont,
}
\lstdefinestyle{maly}{
basicstyle=\smaller[2]\fontfamily{txtt}\fontseries{b}\selectfont,
}
\lstdefinestyle{styleApi}{
morekeywords={enum},
breaklines=true,
breakatwhitespace=true,
breakautoindent=true,
}
\lstset{language=java}

\lstMakeShortInline[style=styleApi]|

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% API definition
\newenvironment{Api}{\begin{itemize}}{\end{itemize}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% API definition code and value
\newcommand{\ApiCode}[1]{\lstinline[style=styleApi]|#1|} 
\newcommand{\ApiValue}[1]{\verb|#1|} 
% \end{verbatim}
% Previous line corrects syntax coloring parser from TexMaker

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% API definition item
\newcommand{\ApiItem}[1]{\item #1 %

% Previous empty line is intended to be blank (wraps the text 
% to the next line even if the \ApiItem is not followed by empty line)
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% API command
\newcommand{\ApiCmd}[1]{\ApiItem{\ApiCode{#1}}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% API atomic type
\newcommand{\ApiType}[2]{\ApiItem{\ApiCode{#1 = #2}}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% API class
\newcommand{\ApiClass}[2]{\ApiItem{%
  \ifx&#2& \ApiCode{class #1} \else \ApiCode{class #1 extends #2} \fi}%
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% API class attributes
\newenvironment{ApiClassAttributes}{% Next empty line is intended to be blank

\begin{samepage}\textbf{Attributes:}\begin{compactitem}}{\end{compactitem}\end{samepage}}
\newcommand{\ApiRequired}{\hspace{1mm}({\color{blue!50!black}\textbf{Required}})}
\newcommand{\ApiOptional}{\hspace{1mm}({\color{gray}\textbf{Optional}})}
\newcommand{\ApiReadOnly}{\hspace{1mm}({\color{red!50!black}\textbf{ReadOnly}})}
\newcommand{\ApiClassAttribute}[3]{\ApiItem{\ApiCode{#2} \ApiCode{#1}
  \ifx\ApiRequired#3\relax \ApiRequired \else \ifx&#3& \ApiOptional \else #3 \fi \fi}%
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% API enum
\newcommand{\ApiEnum}[1]{\ApiItem{\ApiCode{enum #1}}}
\newenvironment{ApiEnumValues}{% Next empty line is intended to be blank

\begin{samepage}\textbf{Enumeration values:}\begin{compactitem}}{\end{compactitem}\end{samepage}}
\newcommand{\ApiEnumValue}[2]{\ApiItem{{\ApiCode{#1} \ifx&#2& \else \hspace{1mm} \ApiValue{\{#2\}} \fi}}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% API example
\newcommand{\ApiExample}{% Next empty line is intended to be blank

\textbf{Example:}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% API note
\newcommand{\ApiNote}{% Next empty line is intended to be blank

\textbf{Note:}
}

%{{{
\makeatletter
% we need to take only part of the \usecounter definition for DCcounter - no
% resets are wanted after end of the environment
\newcounter{UCcounter}
\setcounter{UCcounter}{0}
\newenvironment{UseCases}%
	{\begin{list}{\textbf{UC-\arabic{UCcounter}}}{\@nmbrlisttrue\def\@listctr{UCcounter}}}%
	{\end{list}}
\newcommand{\UClabel}[1]{\label{UC:#1}}
\newcommand{\UCref}[1]{UC-\ref{UC:#1}}

\newcommand{\UseCase}[2]{\item\UClabel{#2} \textbf{(#2) #1}\\ \nopagebreak}

\makeatother
%}}}

\usepackage{xcolor}
\newcommand{\TODO}[1]{%
\def\empty{}%
\def\prvniparametr{#1}%
\ifx\prvniparametr\empty%
\begingroup\tt\textcolor{red}{\noindent\textbf{TODO}}\endgroup
\else%
\begingroup\tt\textcolor{red}{\noindent\textbf{TODO:}\ #1}\endgroup
\fi%
} 


\begin{document}

\title{API for Shongo}
\author{Petr Holub, Jan Růžička, Miloš Liška, Martin Šrom, Ondřej Pavelka, Ondřej Bouda}
\date{\copyright~CESNET~z.\,s.\,p.\,o.\\2012}

\maketitle

\tableofcontents

\chapter{Use Cases}

\section{Resources}

\begin{UseCases}

\UseCase{Types of resources}{res:types}

Basic resource types include the following:

\begin{compactdesc}

\item[A managed endpoint]

This is an endpoint, that is managed by Shongo -- the endpoint is both managed
(calls are automatically dialed when involved in reservation, directory is
updated, etc.) and monitored (availability and status).

\item[A unmanaged endpoint] 

This is an endpoint, which is not available for Shongo management for either
technical or administrative reason. It may be, e.g., a software H.323 client or
web browser acting as a Adobe Connect client. Its specification by a user
(e.g., providing attributes like H.323 number or H.323 ID), however, allows for
specific adjustments during implementation of the reservation -- e.g.,
monitoring of participants in the calls and allowing only participants calling
from specific H.323 number or ID.

\item[A managed infrastructure element]

This is one of the infrastructure resources, that is managed, monitored and
typically also scheduled by the Shongo. It includes things such as H.323 MCUs,
H.323 gatekeepers, Adobe Connect servers, recording servers, streaming servers,
and various types of gateways and translators.

\item[A virtual room] 

A virtual room is a private compartment on a specific multi-point
infrastructure element. Typically, this is comes as a product of a scheduling
process. Virtual rooms are often not licensed, only their participants are
(this is a concurrent user license model). However, other models may also
exists and this is abstraction allows for them.

\item[A license]

This is typically the limiting factor of infrastructure elements in a
concurrent user licensing model. Utilization of the licenses is scheduled by
Shongo, while some licenses may be put aside as a part of permanent
reservations by a resource owner (see \UCref{rsv:reservation:permanent}).

\item[A physical room]

This a representation of a physical meeting room and Shongo thus allows for
reserving physical rooms. Its representation among the resources enables also
more advanced uses: a physical room may contain multiple videoconferencing
devices and reserving a room also means that the those devices become
unavailable for other reservations than the one which contains the physical
room.

\item[A specific identifier]

A user may reserve a specific identifier, typically Adobe Connect URL, H.323
number, or streaming server URL. This allows for reuse of such an identifier in
irregularly recurring and \emph{ad hoc} events.

\end{compactdesc}


\UseCase{Management of resources}{res:management}

The resource owner should be able to create new resources that will be managed by Shongo. Owner should be able to modify the managed resource parameters and also should be able to delete the managed resource.

\UseCase{Resource identification}{res:identification}

Each resource is identified by an unique identifier. The identifier will be 
assigned to the resource by it's owner when the resource is being created 
(\TODO{or modified too?}). The identifier follows the URN standard \cite{rfc2141}:
\begin{verbatim}
urn:id:domain(.subdomain)*.name
\end{verbatim}
Examples: 
\begin{compactitem}
\item \ApiValue{urn:id:cz.muni.fi.sitola.c90} -- H.323 endpoint at C90 room
\item \ApiValue{urn:id:cz.cesnet.srom} -- personal H.323 Mirial endpoint
\end{compactitem}

Each resource has own |name| and belongs to some main |domain|. The domain then can be structured to any number of |subdomain|s. For unmanaged resources that don't belong to any domain there is default |unmanaged| domain which can be followed by the resource type and identity.

Examples: 
\begin{compactitem}
\item \ApiValue{urn:id:unamanged:h323:<H.323 id or number>}
\item \ApiValue{urn:id:unmanaged:connect:<shibboleth identity>}
\end{compactitem}

By the resource identifier, the user can lookup resource type and all other attributes.

\end{UseCases}


\section{Reservations}

\begin{UseCases}

\UseCase{Types of specifications}{rsv:specifications}

Specification of a resource, being object of a reservation, may be of the
following types:

\begin{compactitem}

\item a \emph{fully-qualified explicit specification (FQESpec)} -- specifies
exactly one element; it ma refer to a specific device (e.g., H.323 endpoint,
web browser as an endpoint for Adobe Connect), a specific server (e.g., a
specific Adobe Connect server or H.323 MCU), a specific physical room, or a
specific virtual room (e.g., a specific room running on specific H.323 MCU),

FQESpec may be managed by Shongo or not; for resources that Shongo does not
manage or knows about, i.e., unmanaged resources, the user needs to specify
type of the resource (e.g., generic H.323 endpoint). The unmanaged resources
should have some form of identification (e.g., H.323 number, H.323 ID, or
Shibboleth identity for Adobe Connect) so that Shongo can verify if they are
connected to the virtual room or not during the conference. 

Anonymous unmanaged resources may also be available (completely generic H.323
enpoint without a number or H.323 ID, or guest user in Adobe Connect) , but
some functionality may not be available -- when maximum room capacity is
achieved (or exceeded), anonymous users not be allowed in (or even be
disconnected in LIFO mode until maximum amount of participants is obeyed).


\item a \emph{partially-qualified explicit specification (PQESpec)} --
specifies a class/type of a resource (e.g., H.323 endpoint) and it is up to the
scheduling to find suitable one (combination of availability and access-level
for given user),

\item a \emph{implicit specification (ISpec)} -- the user does not specify such
a resource, but the resource is needed to implement user's request (e.g., if
user specifies Connect and H.323 endpoints, a gateway/connector is needed to
implement the translation; if user specifies multiple H.323 endpoints beyond
MCU-capability of each of them, some MCU is needs to be included).  

\end{compactitem}

Generally, Shongo should use the technology to limit number of participants in
the rooms created based on the reservations---e.g., H.323 MCUs allow for
setting an upper limit on number of participant in each room.

\UseCase{User roles}{rsv:roles}

Each reservation should have at least two types of possible user roles:

\begin{compactitem}

\item \emph{owner/administrator}, who can modify or even delete the reservation,

\item \emph{manager}, who can control the room (e.g., disconnect participants, mute participants, etc.),

\item \emph{participant}, who can only view the reservation including coordinates necessary for participation.

\end{compactitem}

The roles can be delegated, which is important especially in case of owner/administrator: the original reservation creator can delegate this role to other users and any of them can the modify or delete the reservation.


\UseCase{Reservation identification}{rsv:identification}

Each reservation is identified by an unique identifier. The identifier follows the URN standard \cite{rfc2141} and it is assigned to reservation automatically:
\begin{verbatim}
urn:uuid:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
\end{verbatim}
The |xx...xx| represents UUID \cite{rfc4122} which is generated automatically and it provides uniqueness in distributed systems without need for central coordination.


\UseCase{One time reservation}{rsv:reservation:one}

Common type of reservation, where a user requests certain resources for limited
time duration. Unlimited reservations are not assumed by this scenario (see
\UCref{rsv:reservation:permanent}).

Start time of a reservation may be any time in the future or \emph{now}, which
is also called \emph{ad hoc} reservation.

Reserved resources may be given as FQESpec, PQESpec, or ISpec. FQESpec are
either accepted or denied by the scheduler, while other types of the
specifications are looked for their best match. PQESpec may include the
following:

\begin{compactitem}

\item user may request a general endpoint and Shongo should try to find the
closest matching endpoint available to the user (e.g., user requests a H.323
endpoint for a conference since she has no personal endpoint, and she is
assigned a room-based H.323 endpoint provided the room is available),

\end{compactitem}

while examples of ISpec are as follows:

\begin{compactitem}

\item amount of central resources (such as H.323 MCU ports or Connect licenses)
based on specified number of (H.323/SIP or web-browser) participants,

\item any interconnecting elements (e.g., gateways) to interconnect the
endpoints specified by the user; if only part of the endpoints can be
interconnected, the user should be notified what parts can be interconnected
and what parts are disconnected.

\end{compactitem}

Each reservation has to be given a unique identifier that is further used for
any references to it. If the reservation is denied, reasons for denying should
be communicated to the requester. In case that the reservation succeeds, all
the users involved should be notified.


Each reservation has to include:

\begin{compactitem}

\item unique identifier,

\item timespan definition,

\item requester's identifier,

\item name,

\item links to the resources involved, including specification of the amount of resources consumed,

\item list of users involved.

\end{compactitem}

Reservations may be compounded to form another reservation. This allows to
reuse elements that are already reserved (e.g., a specified identifier or
allocation of a physical room) to implement a larger reservation. As a part of
the scheduling process, the scheduler has to check whether the reservation
times and durations are compatible.


\UseCase{Periodic reservation}{rsv:reservation:periodic}

\UCref{rsv:reservation:one} extended with periodicity. Expressiveness of the
periodicity language should be equivalent to cron plus start time, stop time or number of repetition, and explicit lists for recurring aperiodic requests.

\UseCase{Permanent reservation}{rsv:reservation:permanent}

This is specific type of reservation that can be only made by an owner of the
resource as it permanently removes the reserved capacity from the dynamic
Shongo scheduling.

Even permanent reservations must not threaten what has already been reserved for any user. In case of priority requests (see \UCref{rsv:priority}), Shongo must be able to migrate the reservation to other resources.

\UseCase{Priority reservations}{rsv:priority}

Priority reservations are only allowed by an owner of the resources and they
may affect reservations already present on the resources. However, priority
reservation should only be allowed if there is some other resource(s) (maybe
even in another domain) that can take over the prior reservation. In case of
reservation migration, all the involved users must be notified
(see~\UCref{rsv:migration}).

\TODO{We need to decide, whether to allow this or not.}


\UseCase{Maximum future time for reservations}{rsv:max-future}

Each resource owner should set a date/time limit in the future (e.g., 2
months), above which reservations are not allowed. That should be done for each owned resource. Whole reservation duration
must fit in that limit. This limit ensures there is some time point in the
future, where there are no reservations on the resource---e.g., for
maintainance purposes, removal of the device, special events the device will be
used for, etc.


\UseCase{Lookup available time}{rsv:lookup:time}

User may look up available time slots for given amount of requested resources,
with either inter-domain negotiation turned off or on (i.e., tell the user when
resources are available within the domain or when merging resources of all the
domains).

\UseCase{List all the reservations}{rsv:list}

Some querying/filtering language needs to be supported to limit list to

\begin{compactitem}

\item room types (H.323, SIP, Connect, etc.),

\item equipment (be it class of equipment or a specific device).

\item reservation owner(s),

\item users involved (may be humans as well as resources, such as rooms with
equipment) involved in the room as participants.

\end{compactitem}

\UseCase{Modification of a reservation}{rsv:modify}

Any attribute of a reservation may be requested to change. The request may be
accepted or denied by the scheduler. In case of the denial, reasons for denial
should be communicated to the requester. If the modification succeeds, all the
users involved should be notified.

\UseCase{Release/canceling of a reservation}{rsv:release}

All the users involved should be notified.

\UseCase{Migration of a reservation}{rsv:migration}

If the change is visible to the users (e.g., typically this would include
change of the server/MCU the users connect to), all the users involved should
be notified.

\UseCase{Notification of participants}{rsv:notification}

In case of making, modifying, or canceling a reservation, all the users
involved should be notified, as specified in \UCref{rsv:reservation:one},
\UCref{rsv:reservation:periodic}, \UCref{rsv:reservation:permanent},
\UCref{rsv:modify}, \UCref{rsv:release}, and \UCref{rsv:migration}. By default,
the users should be notified via email, but it would be interesting to provide
also SMS notification service.

\UseCase{Reservations of rooms, public or semi-private endpoints,
etc.}{rsv:service-users}

Each reservation may include endpoint resources (beyond human users with
private endpoints---H.323/SIP/web), which represent entities such as rooms,
non-personal endpoints, etc., that can be scheduled in a similar way to central
resources.

This type of reservation may be either part of some infrastructure reservation
(see \UCref{rsv:reservation:one}, \UCref{rsv:reservation:periodic},
\UCref{rsv:reservation:permanent}) or standalone reservation (e.g., reservation
of a meeting room with H.323 equipment to disable the room from scheduling for
given time duration).


\UseCase{Reservation of recording capacity}{rsv:recording}

Usually part of some infrastructure reservation (see
\UCref{rsv:reservation:one}, \UCref{rsv:reservation:periodic},
\UCref{rsv:reservation:permanent}), but may be completely standalone in case
that only recording server is used of the Shongo-managed infrastructure.


\UseCase{Reservation of streaming capacity}{rsv:streaming}

May part of some infrastructure reservation (see \UCref{rsv:reservation:one},
\UCref{rsv:reservation:periodic}, \UCref{rsv:reservation:permanent}), but may
be completely standalone in case that only streaming server is used of the
Shongo-managed infrastructure.

\end{UseCases}


\section{Operations}

\begin{UseCases}

\UseCase{Live migration of a virtual room}{ops:migration}

This use case is intended for migration due to planned server maintenance or
unplanned server outage.  Ideally, all the room settings and content should be
transferred to the target room---but some content may be lost in case of
unplanned server failure (namely content migration).

Being able to transfer room settings to another server in case of unplanned
failure also requires that the settings needs to be stored in the Shongo
middleware.

Clients should be automatically redirected to the new server, if technology
permits, or at least notified of the migration (email, SMS---see
\UCref{rsv:notification}).

Some functionality will be common~\UCref{rsv:migration}.

\end{UseCases}

\subsection{Room Management}

\begin{UseCases}

\UseCase{Get room information on Shongo level}{ops:room:shongo-options}

This information typically includes name, owner, date/periodicity, duration and type.


\UseCase{List users}{ops:room:users-list}

Each user should be given a unique identifier in the output list that can be
used for further querying. It should also provide means to identify the same
user (e.g., if the user disconnects--reconnects, it should contain a part that
is common and that denotes the specific user and a part that is specific for
the session, so that if the user is connected twice (one session is in timeout
state and the other session has just been established), we can differentiate
between the two sessions).

\UseCase{Print detailed info about a user in a room}{ops:room:user-info}

Print all the statistics we can get about a user participating in the room. It
should contain technology agnostic part (e.g., when the user joined) and
technology specific part (i.e., H.323 statistics, H.245/SIP capabilities
negotiation info, H.239 content information, etc.).

\UseCase{Set room layout}{ops:room:layout}

Shongo should be able to set up global layout of a room and user-specific
layout, if available through API of virtual room provider.

\UseCase{Disconnect a user}{ops:room:user-disconnect}

Immediate disconnection of a user.

\UseCase{Disable H.239 content from a specific user}{ops:room:disable-user-content}

Disable content the user to be H.239 content provider for the given room. 

\UseCase{Enable H.239 content only from a specific user}{ops:room:specific-user-content}

Enable H.239 content only from the specific user, typically by disabling
content from all other users. Normally, users may fight who is going to be the
content provider.

\UseCase{Mute a user}{ops:room:user-mute} Mutes user on the room level.
Optionally if user's endpoint is also controlled by Shongo, it should provide
means to mute the endpoint (which can be easily unmuted by the user).

\UseCase{Set microphone audio level for a user}{ops:room:user-miclevel}

Sets the audio from the user on the room level. Optionally, if user's endpoint
is also controlled by Shongo, it should provide means to control mic level on
the endpoint. In this case, audio should be normalized on the endpoint before
doing modifications on room level (if the sound is too low or too high and
distorted, it may not be corrected on the MCU).

\UseCase{Set playback audio level for a user}{ops:room:user-playlevel}

This functionality is typically available only when user's endpoint is also
controlled by Shongo.

\UseCase{Disable video of a user}{ops:room:user-video-off}

\UseCase{Video snapshot for a user}{ops:room:user-video-snap}

If provided by the room provider (MCU, web conferencing, etc.), we should be
able to get video snapshot of:

\begin{compactitem}

\item video sent by the user,

\item video received by the user.

\end{compactitem}


\UseCase{Set layout specific for a user}{ops:room:user-layout}

\UseCase{Download and upload room settings}{ops:room:settings-down-up}

We should provide an API that allows for downloading settings of the room to
the maximum extent possible, in order to back it up and reupload it later on.
This is a convenient way to back up setting as well as to reset a newly created
room (e.g., as a part of a new reservation) to old settings.

\UseCase{Download and upload room content (if technology
permits)}{ops:room:content-down-up}

If technology and access policy permits, we should be able to download and
upload content of the room (e.g., documents, notes, polls, etc.). See
\UCref{ops:room:settings-down-up}.

\UseCase{Get/set technology-specific properties for a
room}{ops:room:room-techspec}

This may include specific attributes of the room (typically on room provider
level), such as enabled codecs.

\UseCase{Get/set technology-specific properties for a
user}{ops:room:user-techspec}

\UseCase{Management of recording archives}{ops:recordings-management}

It should be possible to work with the recorded video through Shongo, e.g.,
migrate it from a content server to a storage of a streaming server. Plus it
should be possible for owner/administrator or manager to access URLs of the
recorded content to send them via email. Also, it should be possible to
automatically notify all the (non-anonymous) participants about the recording
via email.

\end{UseCases}



\section{Monitoring \& Management}

\subsection{Shongo management and monitoring}

\begin{UseCases}

\UseCase{List of all the agents in the system}{mgmt:shng:list-agents}

The listing API must including querying language that allows selection of only
a subset based on similar properties like those defined in \UCref{rsv:list}.

\UseCase{List primary and backup controllers}{mgmt:shng:list-controllers}

List all the controllers (primary and backup) for current domain.

\UseCase{List domains}{mgmt:shng:list-domains}

List of all other known domains including references to their domain
controllers and state of connections to them.

\end{UseCases}

\subsection{Server management and monitoring}

\begin{UseCases}

\UseCase{Get server load}{mgmt:srv:get-load}

The API should provide means to get load on the server machine, containing at
least the following:

\begin{compactitem}

\item CPU load

\item memory load

\item disk occupancy

\end{compactitem}

Obviously, this information may or may not be available for specific device.
In case that the information is not available, the API should report this in a
consistent way (specific exception or unique return value).


\UseCase{Schedule server downtime}{mgmt:srv:schedule-downtime}

Downtime scheduling must include change/migration of all the reservations and
live events influenced by the downtime. Conceptually, this is similar to
permanent reservations a bit (\UCref{rsv:reservation:permanent})---the major
difference is that during the downtime, the resource is not available to Shongo
for management and this state is intentional. Downtime is also per-resource and
does not have participants.

\UseCase{Export Shongo stats}{mgmt:export-stats}

Export reservation stats in some common format like CDR.

\end{UseCases}




\chapter{Common Data Types and Object Classes}

In this chapter we describe atomic types, enum types and object classes. In XML-RPC, every atomic type is converted to it's equivalent and each enum is converted to |String|. Object instances are converted to XML-RPC's |struct| and each non-empty object's attribute to XML-RPC |member| which consists of |name| and |value|. Every |struct| also includes one special \ApiValue{class} member which defines object class.

We use XML-RPC empty |struct| to represent |null| values, e.g., when the user want to clear attribute value by |modify| API method, he should set the attribute value to empty |struct| and the value will be cleared on the server.


\section{Common}

\begin{Api}

\ApiClass{AttributeMap<T...>}{Map<String, Object>}
Represents map of attributes for an object of type |T|. Attribute is pair of |name| and |value|, where name is always |String| and value can be of any allowed type. The map for a type |T| can contain only the attributes that are defined in type |T|. If there are specified multiple types (e.g., |AttributeMap<T1, T2, T3>|), the map can contain an attribute from arbitrary specified type.

The attribute map allows to not enumerate all entity attributes in API methods (e.g., for |create|, |modify| or |list| entities).

\end{Api}


\section{Failure Related}

\TODO{In which language should be errors reported and how to perform translations?}
\TODO{Message can be identified based on faultCode, but how about parameters? For instance they can be enclosed by \{\} in faultString from which they can be parsed too. In more complicated scenarios, the faultString can be of an XML structure.}

Failures are propagated through XML-RPC by |faultCode| and |faultString| values. List of common faults:
\begin{compactitem}
\item |faultCode = 0| \\ Unknown fault which is described by |faultString|.
\item |faultCode = 1| \\ The \ApiValue{class} is not defined, the |faultString| specifies which \ApiValue{class}.
\item |faultCode = 2| \\ The attribute is not defined, the |faultString| specifies which attribute in which class.
\item |faultCode = 3| \\ The attribute type is wrong, the |faultString| specifies which attribute in which class and also it specifies the presented and required type.
\item |faultCode = 4| \\ The value of an enum attribute is wrong., the |faultString| specifies which value for which enum type.
\end{compactitem}


\section{Security and Identity Related}

\begin{Api}

\ApiClass{User}{}
Each user that accesses shongo or participates in shongo managed videoconference should be identified by |User| definition.
\begin{ApiClassAttributes}
\ApiClassAttribute{id}{String}{\ApiRequired} 
Equals to eduID identity. In future there can be unique identifier that associates multiple eduID for the same person.
\ApiClassAttribute{name}{String}{\ApiOptional} 
Name is parsed from  eduID identity.
\end{ApiClassAttributes}


\ApiClass{UserSession}{User}
Represents an active user in a |Room| on a |Server|. In some cases, the |User| definition will not be available (e.g., when user is calling from cell phone), then the |id| attribute will be empty and the |name| attribute will contain special value, \textit{guest} for instance. 
\begin{ApiClassAttributes}
\ApiClassAttribute{roomId}{String}{\ApiRequired} 
Room unique identifier.
\ApiClassAttribute{userId}{String}{\ApiRequired} 
User identification in room (technology specific).
\end{ApiClassAttributes}


\ApiClass{SecurityToken}{User}
Contains identity and credentials of a user performing the requested operation.
\begin{ApiClassAttributes}
\item \TODO{Authorization data}
\end{ApiClassAttributes}

\end{Api}


\section{Time Related}

\begin{Api}

\ApiClass{DateTime}{}
It serves only as base class for |AbsoluteDateTime|, |RelativeDateTime| and |PeriodicDateTime|.


\ApiClass{AbsoluteDateTime}{DateTime}
Represented as ISO8601 date/time (e.g., 20120130T10:09:55). More efficient way of implementation may be used internally, of course.
\begin{ApiClassAttributes}
\ApiClassAttribute{dateTime}{String}{\ApiRequired}
\end{ApiClassAttributes}

\ApiExample We want to define a maximum future time that can be specified as part of some request and we know the precise date (e.g., the date since a resource will not be available for any request). We can specify it by |AbsoluteDateTime|:
\begin{verbatim}
absoluteDateTime.dateTime = 20121231
\end{verbatim}

\ApiClass{RelativeDateTime}{DateTime}
Relative date is calculated as current date and time increased by |duration|.
\begin{ApiClassAttributes}
\ApiClassAttribute{duration}{Duration}{} Default value is zero duration \ApiValue{P0}.
\end{ApiClassAttributes}

\ApiExample We want to define the maximum amount of time since the request moment (e.g., the user can specify dates which are at most 4 months ahead). We can specify it by |RelativeDateTime| as follows:
\begin{verbatim}
relativeDateTime.duration = P4M
\end{verbatim}


\ApiClass{PeriodicDateTime}{DateTime}
It can be used for events that takes place repeatedly, but also for events that take place only once.

\begin{ApiClassAttributes}
\ApiClassAttribute{start}{AbsoluteDateTime}{\ApiRequired}
Defines the first occurrence of an event.
\ApiClassAttribute{period}{Duration}{}
Defines the period in which the repeated events take place.
\ApiClassAttribute{end}{AbsoluteDateTime}{}
Ending date for events to not occur forever.
\ApiClassAttribute{rules}{Rule[]}{}
List of rules, which can define an extra events out of the periodicity or cancel specified periodical events. |Rule| can be one of the following types:
\begin{compactitem}
\item |Enable|/|Disable| event(s) in the specified |dateTime| or interval by |start| and |end|.
\item |Extra| event in the specified |dateTime|
\end{compactitem}
Rules contains implicit definition of |Enable| rule for whole |PeridiocDateTime| interval. Conflicts are solved by \emph{last-match} policy.
\end{ApiClassAttributes}

\ApiExample Only one lecture on 20.3.2012.
\begin{verbatim}
periodicDateTime.start = 20110908T12:00:00
\end{verbatim}

\ApiExample A lecture on every Thursday at 12:00 with extra lecture on 20.3.2012 and Christmas holidays.
\begin{verbatim}
periodicDate.start = 20110908T12:00:00
periodicDate.period = P1W
periodicDate.end = 20120631
periodicDate.rules = {
    { type = Disable, from = 20111219, to = 20120101 },
    { type = Extra, dateTime = 20120320 }
}
\end{verbatim}


\ApiClass{Duration}{}
Represented as ISO8601 duration (e.g., \ApiValue{P3Y6M4DT12H30M5S} which is \textit{3 years, 6 months, 4 days, 12 hours, 30 minutes, and 5 seconds} or \ApiValue{P4W} which is \textit{4 weeks}). The zero duration is represented by \ApiValue{P0} value.


\ApiClass{TimeSlot = Pair<DateTime, Duration>}{}
Time slot is a pair of |DateTime| and |Duration|. For reservation purposes, the array |TimeSlot[]| should be used to provide the ability to reserve multiple date and times with different durations (e.g., on every Monday from 14:00 to 15:00 and every Thursday from 16:00 to 18:00).

If time slot contains |PeriodicDateTime|, all periodic events can be listed by evaluating time slot to |TimeSlot[]|, where only |AbsoluteDateTime|s are used.

\end{Api}


\section{Reservations and Resources}

\begin{Api}


\ApiEnum{ResourceType}
The resource is one of the types as defined in \UCref{res:types}.
\begin{ApiEnumValues}
\ApiEnumValue{ManagedEndPoint}{}
\ApiEnumValue{UnmanagedEndPoint}{}
\ApiEnumValue{MultipointServer}{}
\ApiEnumValue{GatewayServer}{}
\ApiEnumValue{RecordingServer}{}
\ApiEnumValue{StreamingServer}{}
\ApiEnumValue{VirtualRoom}{}
\ApiEnumValue{License}{}
\ApiEnumValue{Identifier}{}
\ApiEnumValue{Other}{} A physical room for instance.
\end{ApiEnumValues}


\ApiEnum{Technology}
\begin{ApiEnumValues}
\ApiEnumValue{H323}{}
\ApiEnumValue{SIP}{}
\ApiEnumValue{AdobeConnect}{}
\ApiEnumValue{Skype}{}
\end{ApiEnumValues}


\ApiClass{Resolution}{}
\begin{ApiClassAttributes}
\ApiClassAttribute{width}{Integer}{\ApiRequired}
\ApiClassAttribute{height}{Integer}{\ApiRequired}
\end{ApiClassAttributes}
\begin{ApiEnumValues}
\ApiEnumValue{HD}{width = 1920, height = 1080}
\ApiEnumValue{2K}{width = 2048, height = 1080}
\ApiEnumValue{4K}{width = 4096, height = 2160}
\TODO{Complete this}
\end{ApiEnumValues}


\ApiEnum{CodecType}
\begin{ApiEnumValues}
\ApiEnumValue{H261}{}
\ApiEnumValue{H263}{}
\ApiEnumValue{H264}{}
\TODO{Complete this}
\end{ApiEnumValues}


\ApiClass{Codec}{}
Resource technologies can provide different codecs.
\begin{ApiClassAttributes}
\ApiClassAttribute{type}{CodecType}{\ApiRequired}
\ApiClassAttribute{resolution}{Resolution}{\ApiRequired}
\end{ApiClassAttributes}


\ApiClass{Translation}{}
Represents translations that a |GatewayServer| resource can perform.
\begin{ApiClassAttributes}
\ApiClassAttribute{input}{Map<TechnologyType, Codec[]>}{\ApiRequired}
Input technologies with specified codecs that server is able to transform.
\ApiClassAttribute{output}{Map<TechnologyType, Codec[]>}{\ApiRequired}
Output technologies with specified codecs that server is able to produce.
\end{ApiClassAttributes}


\ApiClass{Resource}{}
\begin{ApiClassAttributes}
\ApiClassAttribute{id}{String}{\ApiRequired} Resource unique identifier as defined in \UCref{res:identification}.
\ApiClassAttribute{parentId}{String}{\ApiRequired} A parent resource identifier in which is the resource located (e.g., identifier of a physical room).
\ApiClassAttribute{name}{String}{\ApiRequired} Short name which describes the resource.
\ApiClassAttribute{type}{ResourceType}{\ApiRequired} Type of the resource, see |ResourceType|. 
\ApiClassAttribute{technology}{Technology}{} Technology type of the resource, see |Technology|. 
\ApiClassAttribute{translation}{Translation}{} Translation type of the gateway resource, see |Translation|. 
\ApiClassAttribute{description}{String}{} Long description depicting the resource.
\ApiClassAttribute{maxFuture}{Date}{} The maximum future time for reservations as defined in \UCref{rsv:max-future}.
\ApiClassAttribute{resources}{String[]}{} List of child resources identifiers (e.g., the resource is physical room and |resources| contains all videoconferencing devices in the room). 
\end{ApiClassAttributes}


\ApiEnum{ReservationType}
\begin{ApiEnumValues}
\ApiEnumValue{OneTime}{} One time reservation as defined in \UCref{rsv:reservation:one}.
\ApiEnumValue{Periodic}{} Periodic reservation as defined in \UCref{rsv:reservation:periodic}.
\ApiEnumValue{Permanent}{} Permanent reservation as defined in \UCref{rsv:reservation:permanent}.
\end{ApiEnumValues}


\ApiClass{Reservation}{}
Represents a single reservation.
\begin{ApiClassAttributes}
\ApiClassAttribute{id}{String}{\ApiReadOnly} Reservation unique identifier as defined in \UCref{rsv:identification}.
\ApiClassAttribute{type}{ReservationType}{\ApiRequired} Type of reservation, see |ReservationType|.
\ApiClassAttribute{description}{String}{} Long reservation description.
\end{ApiClassAttributes}


\ApiClass{ReservationDetail}{}
Represents a detail information of a reservation.
\begin{ApiClassAttributes}
\ApiClassAttribute{id}{String}{\ApiReadOnly} Reservation unique identifier as defined in \UCref{rsv:identification}.
\ApiClassAttribute{resources}{Resource[]}{\ApiRequired} List of requested resources by this reservation. Each |Resource| definition has filled the resource identifier (FQESpec) or other attributes that partially specifies the resource (PQESpec).
\ApiClassAttribute{slots}{TimeSlot[]}{\ApiRequired} Requested time slots for the reservation.
\ApiClassAttribute{reservations}{String[]}{} List of child reservations identifiers. All allocated resources from child reservations become part of the parent reservation.
\ApiClassAttribute{allocatedResources}{String[]}{\ApiReadOnly} List of allocated resources identifiers by a scheduler for this reservation. Does not include the child reservations resources, they must be looked up from |reservations|.
\ApiClassAttribute{allocatedSlots}{TimeSlot[]}{\ApiReadOnly} Requested time slots for specified resources.
\ApiClassAttribute{users}{User[]}{} List of users that will be permitted to participate in the videoconference. The list can contain several empty |User| definitions to allow guests.
\end{ApiClassAttributes}


\ApiClass{Room}{}
Represents a virtual room on a specific resource of |Server| type (such as H.323 MCU).
\begin{ApiClassAttributes}
\ApiClassAttribute{id}{String}{\ApiReadOnly} Room unique identifier.
\ApiClassAttribute{resourceId}{String}{\ApiReadOnly} Server resource identifier.
\end{ApiClassAttributes}

\end{Api}




\chapter{User Interface API Specification}

\section{Resources}

\begin{Api}

\ApiCmd{Resource createResource(SecurityToken token, String domain, AttributeMap<Resource> attributes)}
Create a new resource that will be managed by Shongo. The user with given |token| will be the resource owner.

\ApiCmd{Resource modifyResource(SecurityToken token, String resourceId, AttributeMap<Resource> attributes)}
Modify the resource with specified |resourceId|. That operation is permited only when the user with given |token| is the resource owner.

\ApiCmd{deleteResource(SecurityToken token, String resourceId)}
Delete the resource with specified |resourceId| from Shongo management. That operation is permited only when the user with given |token| is the resource owner and only when the resource is not used in any future reservation.

\ApiCmd{Resource[] listResources(SecurityToken token, AttributeMap<Resource> filter)}
List of resources managed by Shongo, that a user with given |token| is entitled to see and that meet the resource |filter|.

\end{Api}


\section{Reservations}

\begin{Api}

\ApiCmd{Reservation createReservation(SecurityToken token, AttributeMap<Reservation, ReservationDetail> attributes)}
Create a new reservation. The new reservation identifier is included in returned object as |id| attribute.

\ApiCmd{modifyReservation(SecurityToken token, String reservationId, AttributeMap<Reservation, ReservationDetail> attributes)}
Modify the reservation with specified |reservationId|.

\ApiCmd{deleteReservation(SecurityToken token, String reservationId)}
Release the reservation with specified |reservationId|. The child reservations remain untouched.

\ApiCmd{ReservationDetail getReservationDetail(SecurityToken token, String reservationId)}
Get the reservation detail for specified |reservationId| that a user with given |token| is entitled to see.

\ApiCmd{Reservation[] listReservations(SecurityToken token, AttributeMap<Reservation> filter)}
List all the reservations that a user with given |token| is entitled to see and that meet the reservation |filter|.

\ApiCmd{Resource[] listReservationResources(SecurityToken token, String reservationId)}
List all the resources that was allocated by a scheduler for the reservation and for all child reservation (recursive).

\ApiCmd{TimeSlot[] findReservationAvailableTime(SecurityToken token, Duration duration, Resource[] resources, boolean interDomain)}
Lookup available time slots for specified reservation |duration| and |resources|. Flag |interDomain| specifies whether inter-domain lookup should be performed.

\end{Api}


\section{Room Operations}

\begin{Api}

\ApiCmd{Room[] listReservationRooms(SecurityToken token, String reservationId)}
Lists all the virtual rooms including rooms that are part of any child reservations.

\ApiCmd{boolean isRoomActive(SecurityToken token, Room room)}
Checks whether the specified |room| is currently used by any reservation.

\ApiCmd{User[] listRoomUsers(SecurityToken token, Room room)}
Retrieve list of users that currently participate in the specified |room|.

\ApiCmd{disconnectRoomUser(SecurityToken token, Room room, User user)}
Disconnect the specified |user| from the |room| in which he is currently participating.

\ApiCmd{muteRoomUser(SecurityToken token, Room room, User user)}
Mute the |user| microphone in the specified |room| in which he is currently participating.

\ApiCmd{setRoomUserMicLevel(SecurityToken token, Room room, User user, int level)}
Set the |user| microphone level in the specified |room| in which the |user| is currently participating.

\ApiCmd{setRoomUserPlaybackLevel(SecurityToken token, Room room, User user, int level)}
Set the |user| playback level in the specified |room| in which the |user| is currently participating (alters his speakers volume).

\end{Api}


\chapter{Connector API Specification}

\section{Data Types}

\begin{Api}

\ApiClass{Event}{}
Represents abstract event that takes place on specified |dateTime| and takes |duration| period of time.
\begin{ApiClassAttributes}
\ApiClassAttribute{dateTime}{AbsoluteDateTime}{\ApiRequired}
\ApiClassAttribute{duration}{Duration}{\ApiRequired}
\end{ApiClassAttributes}

\ApiClass{EndpointEvent}{Event}
Specialized event for endpoint device.
\begin{ApiClassAttributes}
\ApiClassAttribute{server}{String}{\ApiRequired} Specifies the server to which the endpoint should connect to.
\end{ApiClassAttributes}

\ApiClass{ServerEvent}{Event}
\begin{ApiClassAttributes}
\ApiClassAttribute{allowedClients}{String[]}{\ApiRequired} Specifies the client that are permitted to connect to server.
\end{ApiClassAttributes}

\end{Api}

\section{Common API}

\begin{Api}

\ApiCmd{String getResourceId()}
Get unique identifier of a resource that is managed by the connector.

\end{Api}

\section{Reservation API}

\begin{Api}

\ApiCmd{setCalendar(Event[] calendar)}

\end{Api}

\section{User Management API}

\section{Monitoring API}

\begin{Api}

\ApiCmd{boolean isStarted()}

\end{Api}

\section{Application Specific API}




\chapter{Inter-Controller API Specification}


\appendix

\chapter{User Interface API Usage}

\section{Perl programming language}
\newenvironment{PerlCmd}{\small\verbatim}{\endverbatim}
\newenvironment{PerlResponse}{\textbf{Response}\small\verbatim}{\endverbatim}

\subsection{Connect to Controller}

\begin{PerlCmd}
#!/usr/bin/perl

require RPC::XML;
require RPC::XML::Client;

$client = RPC::XML::Client->new('http://localhost:8008');

$response = $client->send_request(...);

if ( ref($response) ) {
    use XML::Twig;
    $xml = XML::Twig->new(pretty_print => 'indented');
    $xml->parse($response->as_string());
    $xml->print();
} else {
    print($response . "\n");
}
\end{PerlCmd}

\newpage
\subsection{Create reservation}
\begin{PerlCmd}
$response = $client->send_request(
    'Reservations.createReservation',
    RPC::XML::struct->new(
        'class' => RPC::XML::string->new('SecurityToken'),
        ...
    ),
    RPC::XML::struct->new(
        'class' => RPC::XML::string->new('AttributeMap'),
        'type' => RPC::XML::string->new('OneTime'),
        'date' => RPC::XML::struct->new(
            'class' => RPC::XML::string->new('Date'),
            'date' => RPC::XML::string->new('20120101')
        )
    )
);
\end{PerlCmd}
\begin{PerlResponse}
<struct>
  <member>
    <name>class</name>
    <value><string>Reservation</string></value>
  </member>
  <member>
    <name>id</name>
    <value>
      <string>e5a6ee96-8ac5-46dc-ac3b-5374076aee1b</string>
    </value>
  </member>
  <member>
    <name>type</name>
    <value><string>OneTime</string></value>
  </member>
  <member>
    <name>date</name>
    <value><struct>
        <member>
          <name>class</name>
          <value><string>Date</string></value>
        </member>    
        <member>
          <name>date</name>
          <value><string>20120101</string></value>
        </member>
    </struct></value>
  </member>
</struct>
\end{PerlResponse}

\newpage
\subsection{Modify reservation}
\begin{PerlCmd}
$response = $client->send_request(
    'Reservations.modifyReservation',
    RPC::XML::struct->new(
        'class' => RPC::XML::string->new('SecurityToken'),
        ...
    ),
    RPC::XML::string->new('15082783-5b6f-4287-9015-3dbc0ab2f0d9'),
    RPC::XML::struct->new(
        'class' => RPC::XML::string->new('AttributeMap'),
        'description' => RPC::XML::struct->new() # set description to null
    )
);
\end{PerlCmd}
\begin{PerlResponse}
<struct>
  <member>
    <name>id</name>
    <value><string>15082783-5b6f-4287-9015-3dbc0ab2f0d9</string></value>
  </member>
  <member>
    <name>class</name>
    <value><string>Reservation</string></value>
  </member>
  <member>
    <name>type</name>
    <value><string>OneTime</string></value>
  </member>
</struct>
\end{PerlResponse}

\newpage
\subsection{List reservations}
\begin{PerlCmd}
$response = $client->send_request(
    'Reservations.listReservations',
    RPC::XML::struct->new(
        'class' => RPC::XML::string->new('SecurityToken'),
        ...
    )
);
\end{PerlCmd}
\begin{PerlResponse}
<array><data>
  <value><struct>
    <member>
      <name>class</name>
      <value><string>Reservation</string></value>
    </member>
    <member>
      <name>id</name>
      <value><string>15082783-5b6f-4287-9015-3dbc0ab2f0d9</string></value>
    </member>
    <member>
      <name>type</name>
      <value><string>Periodic</string></value>
    </member>
  </struct></value>
</data></array>
\end{PerlResponse}

\newpage
\subsection{Exception handling}
\subsubsection{Wrong class}
\begin{PerlCmd}
$response = $client->send_request(
    'Reservations.listReservations',
    RPC::XML::struct->new(
        'class' => RPC::XML::string->new('SecurityTokenX'),
        ...
    )
);
\end{PerlCmd}
\begin{PerlResponse}
<fault>
  <value><struct>
    <member>
      <name>faultString</name>
      <value><string>Class 'SecurityTokenX' is not defined.</string></value>
    </member>
    <member>
      <name>faultCode</name>
      <value><i4>1</i4></value>
    </member>
  </struct></value>
</fault>
\end{PerlResponse}

\subsubsection{Wrong attribute name}
\begin{PerlCmd}
$response = $client->send_request(
    'Reservations.listReservations',
    RPC::XML::struct->new(
        'class' => RPC::XML::string->new('SecurityToken'),
        ...
    ),
    RPC::XML::struct->new(
        'class' => RPC::XML::string->new('AttributeMap'),
        'typeX' => RPC::XML::string->new('OneTime')
    )
);
\end{PerlCmd}
\begin{PerlResponse}
<fault>
  <value><struct>
    <member>
      <name>faultString</name>
      <value><string>Attribute 'typeX' in class 'Reservation' is not defined.</string></value>
    </member>
    <member>
      <name>faultCode</name>
      <value><i4>2</i4></value>
    </member>
  </struct></value>
</fault>
\end{PerlResponse}

\subsubsection{Wrong attribute value}
\begin{PerlCmd}
$response = $client->send_request(
    'Reservations.listReservations',
    RPC::XML::struct->new(
        'class' => RPC::XML::string->new('SecurityToken'),
        ...
    ),
    RPC::XML::struct->new(
        'class' => RPC::XML::string->new('AttributeMap'),
        'type' => RPC::XML::struct->new(
            'class' => RPC::XML::string->new('Date'),
            'date' => RPC::XML::string->new('20120101')
        )
    )
);
\end{PerlCmd}
\begin{PerlResponse}
<fault>
  <value><struct>
    <member>
      <name>faultString</name>
      <value><string>Attribute 'type' in class 'Reservation' has type 
          'ReservationType' but 'Date' was presented.</string></value>
    </member>
    <member>
      <name>faultCode</name>
      <value><i4>3</i4></value>
    </member>
  </struct></value>
</fault>
\end{PerlResponse}

\subsubsection{Wrong enum}
\begin{PerlCmd}
$response = $client->send_request(
    'Reservations.listReservations',
    RPC::XML::struct->new(
        'class' => RPC::XML::string->new('SecurityToken'),
        ...
    ),
    RPC::XML::struct->new(
        'class' => RPC::XML::string->new('AttributeMap'),
        'type' => RPC::XML::string->new('OneTimeX')
    )
);
\end{PerlCmd}
\begin{PerlResponse}
<fault>
  <value><struct>
    <member>
      <name>faultString</name>
      <value><string>Enum value 'OneTimeX' is not defined in enum
          'ReservationType'.</string></value>
    </member>
    <member>
      <name>faultCode</name>
      <value><i4>4</i4></value>
    </member>
  </struct></value>
</fault>
\end{PerlResponse}

\subsubsection{Bussiness logic exception}
\begin{PerlCmd}
$response = $client->send_request(
    'Reservations.createReservation',
    RPC::XML::struct->new(
        'class' => RPC::XML::string->new('SecurityToken'),
        ...
    ),
    RPC::XML::struct->new(
        'class' => RPC::XML::string->new('AttributeMap'),
        'type' => RPC::XML::string->new('Periodic'),
        'date' => RPC::XML::struct->new(
            'class' => RPC::XML::string->new('Date'),
            'date' => RPC::XML::string->new('20120101')
        )
    )
);
\end{PerlCmd}
\begin{PerlResponse}
<fault>
  <value><struct>
    <member>
      <name>faultString</name>
      <value><string>Periodic date is required.</string></value>
    </member>
    <member>
      <name>faultCode</name>
      <value><i4>102</i4></value>
    </member>
  </struct></value>
</fault>
\end{PerlResponse}



\bibliographystyle{elsarticle-num}
\bibliography{IEEEabrv,API}

\end{document}

