package cz.cesnet.shongo.controller.resource;

import cz.cesnet.shongo.AliasType;
import cz.cesnet.shongo.Technology;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.Set;

/**
 * {@link AliasGenerator} based on pattern.
 *
 * @author Martin Srom <martin.srom@cesnet.cz>
 */
public class AliasPatternGenerator extends AliasGenerator
{
    /**
     * Already used {@link Alias#value}s.
     */
    Set<String> usedValues = new HashSet<String>();

    /**
     * Pattern for the alias.
     */
    private Pattern pattern = new Pattern();

    /**
     * Constructor.
     *
     * @param pattern pattern for aliases.
     */
    public AliasPatternGenerator(Technology technology, AliasType type, String pattern)
    {
        super(technology, type);

        this.pattern.parse(pattern);
    }

    /**
     * @param value already used alias value to not be generated by the generator
     */
    public void addAliasValue(String value)
    {
        usedValues.add(value);
    }

    @Override
    public void addAlias(Alias alias)
    {
        if (alias.getTechnology() != technology) {
            throw new IllegalStateException("Alias technology '" + alias.getTechnology().toString() + "' should be '"
                    + technology.toString() + "'");
        }
        if (alias.getType() != type) {
            throw new IllegalStateException("Alias type '" + alias.getType().toString() + "' should be '"
                    + type.toString() + "'");
        }
        addAliasValue(alias.getValue());
    }

    @Override
    public Alias generate()
    {
        String value = null;
        pattern.reset();
        do {
            value = pattern.generate();
        } while (value != null && usedValues.contains(value));
        if (value == null) {
            return null;
        }

        addAliasValue(value);

        Alias alias = new Alias();
        alias.setTechnology(technology);
        alias.setType(type);
        alias.setValue(value);
        return alias;
    }

    /**
     * Alias patter.
     */
    public static class Pattern extends ArrayList<PatternComponent>
    {
        /**
         * Regex for {@link NumberPatternComponent}.
         */
        private static final java.util.regex.Pattern NUMBER_PATTERN = java.util.regex.Pattern.compile("d+");

        /**
         * Single value pattern.
         */
        private boolean singleValuePattern = false;

        /**
         * Generated count.
         */
        private int generatedCount = 0;

        /**
         * Parse pattern from string.
         *
         * @param pattern string to be parsed
         */
        public void parse(String pattern)
        {
            int start = -1;
            int end = -1;
            while ((start = pattern.indexOf('[')) != -1 && (end = pattern.indexOf(']')) != -1) {
                if (start > 0) {
                    add(new StringPatternComponent(pattern.substring(0, start)));
                }
                String component = pattern.substring(start + 1, end);
                if (NUMBER_PATTERN.matcher(component).matches()) {
                    add(new NumberPatternComponent(component.length()));
                }
                else {
                    throw new IllegalArgumentException("Component '[" + component + "]' is in wrong format.");
                }
                pattern = pattern.substring(end + 1);
            }
            if (pattern.length() > 0) {
                add(new StringPatternComponent(pattern));
            }
            singleValuePattern = size() == 1 && get(0) instanceof StringPatternComponent;
        }

        /**
         * Reset all pattern components
         */
        public void reset()
        {
            generatedCount = 0;
            for (PatternComponent patternComponent : this) {
                if (patternComponent instanceof GeneratedPatternComponent) {
                    GeneratedPatternComponent generatedPatternComponent = (GeneratedPatternComponent) patternComponent;
                    generatedPatternComponent.reset();
                }
            }
        }

        /**
         * @return new generated value from the pattern
         */
        public String generate()
        {
            StringBuilder builder = new StringBuilder();
            boolean performNextComponent = true;
            for (int index = size() - 1; index >= 0; index--) {
                PatternComponent patternComponent = get(index);
                if (patternComponent instanceof GeneratedPatternComponent) {
                    GeneratedPatternComponent generatedPatternComponent = (GeneratedPatternComponent) patternComponent;
                    if (performNextComponent) {
                        generatedPatternComponent.nextComponent();
                    }
                    if (generatedPatternComponent.available()) {
                        performNextComponent = false;
                    }
                    else {
                        performNextComponent = true;
                        generatedPatternComponent.reset();
                    }
                }
                builder.insert(0, patternComponent.getComponent());
            }

            if (performNextComponent && (!singleValuePattern || generatedCount > 0)) {
                return null;
            }
            generatedCount++;
            return builder.toString();
        }
    }

    /**
     * Pattern component.
     */
    private static interface PatternComponent
    {
        /**
         * @return new value for pattern component if possible, null otherwise
         */
        public String getComponent();
    }

    /**
     * {@link PatternComponent} which returns always same string.
     */
    private static class StringPatternComponent implements PatternComponent
    {
        /**
         * Same string which is returned
         */
        private String component;

        /**
         * Constructor.
         *
         * @param component sets the {@link #component}
         */
        public StringPatternComponent(String component)
        {
            this.component = component;
        }

        @Override
        public String getComponent()
        {
            return component;
        }
    }

    /**
     * {@link PatternComponent} which returns generated component.
     */
    private static interface GeneratedPatternComponent extends PatternComponent
    {
        /**
         * Reset generating.
         */
        public void reset();

        /**
         * Generate next component.
         */
        public void nextComponent();

        /**
         * @return true if next generated value is available, false otherwise
         */
        public boolean available();
    }

    /**
     * {@link PatternComponent} which returns increasing numbers of given length.
     */
    private static class NumberPatternComponent implements GeneratedPatternComponent
    {
        /**
         * Format for numbers.
         */
        private String format;

        /**
         * Current number.
         */
        private int currentValue;

        /**
         * Maximum number which is possible for given length.
         */
        private int maxValue;

        /**
         * Constructor.
         *
         * @param length maximum returned number length
         */
        public NumberPatternComponent(int length)
        {
            if (length < 1 || length > 10) {
                throw new IllegalArgumentException("Length of number component should be in range from 1 to 10.");
            }
            this.format = "%0" + Integer.valueOf(length).toString() + "d";
            this.maxValue = (int) Math.pow(10, length) - 1;
            reset();
        }

        @Override
        public void nextComponent()
        {
            currentValue++;
        }

        @Override
        public String getComponent()
        {
            if (currentValue > maxValue) {
                return null;
            }
            return String.format(format, currentValue);
        }

        @Override
        public void reset()
        {
            currentValue = 0;
        }

        @Override
        public boolean available()
        {
            return currentValue <= maxValue;
        }
    }
}
