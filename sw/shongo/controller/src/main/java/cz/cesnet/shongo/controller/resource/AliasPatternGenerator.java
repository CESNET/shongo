package cz.cesnet.shongo.controller.resource;

import cz.cesnet.shongo.fault.TodoImplementException;
import org.apache.commons.lang.RandomStringUtils;

import java.util.*;

/**
 * {@link AliasGenerator} based on pattern.
 *
 * @author Martin Srom <martin.srom@cesnet.cz>
 */
public class AliasPatternGenerator extends AliasGenerator
{
    /**
     * Already used {@link Alias#value}s.
     */
    Set<String> usedValues = new HashSet<String>();

    /**
     * Patterns for the alias.
     */
    private List<Pattern> patterns = new ArrayList<Pattern>();

    /**
     * Constructor.
     */
    public AliasPatternGenerator()
    {
    }

    /**
     * Constructor.
     *
     * @param pattern pattern for aliases.
     */
    public AliasPatternGenerator(String pattern)
    {
        this(Collections.nCopies(1, pattern));
    }

    /**
     * Constructor.
     *
     * @param patterns patterns for aliases.
     */
    public AliasPatternGenerator(Collection<String> patterns)
    {
        for (String pattern : patterns) {
            addPattern(pattern);
        }
    }

    /**
     * @param patternString from which should be parsed new {@link Pattern} and added to the {@link #patterns}
     */
    public void addPattern(String patternString)
    {
        Pattern pattern = new Pattern();
        pattern.parse(patternString);
        this.patterns.add(pattern);
    }

    /**
     * @param value already used alias value to not be generated by the generator
     */
    @Override
    public void addAliasValue(String value)
    {
        usedValues.add(value);
    }

    @Override
    public String generateValue()
    {
        String value = null;
        for (Pattern pattern : patterns) {
            pattern.reset();
            do {
                value = pattern.generate();
            } while (value != null && usedValues.contains(value));
            if (value != null) {
                break;
            }
        }
        if (value == null) {
            return null;
        }

        addAliasValue(value);

        return value;
    }

    @Override
    public boolean isValueAvailable(String value)
    {
        for (Pattern pattern : patterns) {
            if (pattern.size() == 1) {
                PatternComponent patternComponent = pattern.get(0);
                if (patternComponent instanceof StringPatternComponent) {
                    if (StringPatternComponent.VALUE_PATTERN.matcher(value).matches()) {
                        if (!usedValues.contains(value)) {
                            return true;
                        }
                    }
                }
                else {
                    throw new TodoImplementException("AliasPatternGenerator.isValueAvailable for %s.",
                            patternComponent.getClass().getSimpleName());
                }
            }
            else {
                throw new TodoImplementException("AliasPatternGenerator.isValueAvailable for multiple components.");
            }
        }
        return false;
    }

    /**
     * Alias patter.
     */
    public static class Pattern extends ArrayList<PatternComponent>
    {
        /**
         * Length of automatic generated strings by "[s]" pattern.
         */
        public static final int STRING_PATTERN_LENGTH = 8;

        /**
         * Regex for {@link NumberPatternComponent}.
         */
        private static final java.util.regex.Pattern NUMBER_PATTERN = java.util.regex.Pattern.compile("d+");

        /**
         * Regex for {@link StringPatternComponent}
         */
        private static final java.util.regex.Pattern STRING_PATTERN = java.util.regex.Pattern.compile("s");

        /**
         * Single value pattern.
         */
        private boolean singleValuePattern = false;

        /**
         * Generated count.
         */
        private int generatedCount = 0;

        /**
         * Parse pattern from string.
         *
         * @param pattern string to be parsed
         */
        public void parse(String pattern)
        {
            int start = -1;
            int end = -1;
            while ((start = pattern.indexOf('[')) != -1 && (end = pattern.indexOf(']')) != -1) {
                if (start > 0) {
                    add(new ConstantPatternComponent(pattern.substring(0, start)));
                }
                String component = pattern.substring(start + 1, end);
                if (NUMBER_PATTERN.matcher(component).matches()) {
                    add(new NumberPatternComponent(component.length()));
                }
                else if (STRING_PATTERN.matcher(component).matches()) {
                    add(new StringPatternComponent());
                }
                else {
                    throw new IllegalArgumentException("Component '[" + component + "]' is in wrong format.");
                }
                pattern = pattern.substring(end + 1);
            }
            if (pattern.length() > 0) {
                add(new ConstantPatternComponent(pattern));
            }
            singleValuePattern = size() == 1 && get(0) instanceof ConstantPatternComponent;
        }

        /**
         * Reset all pattern components
         */
        public void reset()
        {
            generatedCount = 0;
            for (PatternComponent patternComponent : this) {
                if (patternComponent instanceof GeneratedPatternComponent) {
                    GeneratedPatternComponent generatedPatternComponent = (GeneratedPatternComponent) patternComponent;
                    generatedPatternComponent.reset();
                }
            }
        }

        /**
         * @return new generated value from the pattern
         */
        public String generate()
        {
            StringBuilder builder = new StringBuilder();
            boolean performNextComponent = true;
            for (int index = size() - 1; index >= 0; index--) {
                PatternComponent patternComponent = get(index);
                if (patternComponent instanceof GeneratedPatternComponent) {
                    GeneratedPatternComponent generatedPatternComponent = (GeneratedPatternComponent) patternComponent;
                    if (performNextComponent) {
                        generatedPatternComponent.nextComponent();
                    }
                    if (generatedPatternComponent.available()) {
                        performNextComponent = false;
                    }
                    else {
                        performNextComponent = true;
                        generatedPatternComponent.reset();
                    }
                }
                builder.insert(0, patternComponent.getComponent());
            }

            if (performNextComponent && (!singleValuePattern || generatedCount > 0)) {
                return null;
            }
            generatedCount++;
            return builder.toString();
        }
    }

    /**
     * Pattern component.
     */
    private static interface PatternComponent
    {
        /**
         * @return new value for pattern component if possible, null otherwise
         */
        public String getComponent();
    }

    /**
     * {@link PatternComponent} which returns always same string.
     */
    private static class ConstantPatternComponent implements PatternComponent
    {
        /**
         * Same string which is returned
         */
        private String component;

        /**
         * Constructor.
         *
         * @param component sets the {@link #component}
         */
        public ConstantPatternComponent(String component)
        {
            this.component = component;
        }

        @Override
        public String getComponent()
        {
            return component;
        }
    }

    /**
     * {@link PatternComponent} which returns generated component.
     */
    private static interface GeneratedPatternComponent extends PatternComponent
    {
        /**
         * Reset generating.
         */
        public void reset();

        /**
         * Generate next component.
         */
        public void nextComponent();

        /**
         * @return true if next generated value is available, false otherwise
         */
        public boolean available();
    }

    /**
     * {@link PatternComponent} which returns increasing numbers of given length.
     */
    private static class NumberPatternComponent implements GeneratedPatternComponent
    {
        /**
         * Format for numbers.
         */
        private String format;

        /**
         * Current number.
         */
        private int currentValue;

        /**
         * Maximum number which is possible for given length.
         */
        private int maxValue;

        /**
         * Constructor.
         *
         * @param length maximum returned number length
         */
        public NumberPatternComponent(int length)
        {
            if (length < 1 || length > 10) {
                throw new IllegalArgumentException("Length of number component should be in range from 1 to 10.");
            }
            this.format = "%0" + Integer.valueOf(length).toString() + "d";
            this.maxValue = (int) Math.pow(10, length) - 1;
            reset();
        }

        @Override
        public void nextComponent()
        {
            currentValue++;
        }

        @Override
        public String getComponent()
        {
            if (currentValue > maxValue) {
                return null;
            }
            return String.format(format, currentValue);
        }

        @Override
        public void reset()
        {
            currentValue = 0;
        }

        @Override
        public boolean available()
        {
            return currentValue <= maxValue;
        }
    }

    /**
     * {@link PatternComponent} which returns increasing numbers of given length.
     */
    private static class StringPatternComponent implements GeneratedPatternComponent
    {
        /**
         * Pattern for matching correct values.
         */
        private static final java.util.regex.Pattern VALUE_PATTERN =
                java.util.regex.Pattern.compile("^\\p{Alpha}[\\p{Alnum}_]*$");

        /**
         * Current number.
         */
        private String currentValue;

        /**
         * Constructor.
         */
        public StringPatternComponent()
        {
            reset();
        }

        @Override
        public void nextComponent()
        {
            currentValue = RandomStringUtils.randomAlphabetic(1).toLowerCase();
            currentValue += RandomStringUtils.randomAlphanumeric(Pattern.STRING_PATTERN_LENGTH - 1).toLowerCase();
        }

        @Override
        public String getComponent()
        {
            return currentValue;
        }

        @Override
        public void reset()
        {
        }

        @Override
        public boolean available()
        {
            return true;
        }
    }
}
